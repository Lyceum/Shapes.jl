var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [Shapes]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/#Shapes.AbstractShape","page":"API","title":"Shapes.AbstractShape","text":"abstract type AbstractShape{S, T, N, L} end\n\nThe supertype for the various concrete shapes defined by Shapes. The,/StaticArrays.jl). The S parameter is a Tuple-type specifying the dimensions, or size, of the AbstractShape- such as Tuple{3,4,5} for a 3×4×5-sized array. The T parameter specifies the underlying data type of the shape (e.g. the element type for an array shape). The L parameter is the length of the array and is always equal to prod(S). Constructors may drop the L and T parameters if they are inferrable from the input (e.g. L is always inferrable from S).\n\n\n\n\n\n","category":"type"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Shapes provides Julia traits for describing the shape of a value, like a scalar or array.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Shapes can be used for pre-allocating storage and allows for viewing flat, unstructured data (e.g. a Vector{Float64}) as a set of variables, each with their own shapes and data types.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Shapes is heavily inspired by ValueShapes and StaticArrays; it is essentially a statically-sized version of the former, allowing for zero-cost abstractions.","category":"page"},{"location":"#Shape-and-MultiShape-1","page":"Home","title":"Shape and MultiShape","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The core type provided by Shapes.jl is Shape{S,T,N,L}, where S, T, N, and L describe the size, data type, dimensionality, and overall length of the shape, respectively. ScalarShape{T}, VectorShape{T, L}, and MatrixShape{M, N, T} aliases are provided for convenience.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Shapes\n\njulia> shape = MatrixShape(Float64, 5, 10)\nShape{Tuple{5,10},Float64,2,50}()","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Shapes can be used with a variety of Base functions to describe different aspects of the Shape:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> size(shape) == (5, 10) && length(shape) == 50 && ndims(shape) == 2\ntrue\njulia> axes(shape) # Shapes uses the static ranges provided by StaticArrays.jl\n(SOneTo(5), SOneTo(10))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Shapes also distinguish between its possibly abstract data type and the underlying concrete storage type:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> shape = VectorShape(Real, 5);\n\njulia> eltype(shape)\nReal\n\njulia> concrete_eltype(shape) # The default for T, where Real <: T <: Number, is Float64.\nFloat64","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This can be used for pre-allocating concrete storage for a Shape:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> x = Array(undef, shape, 100);\n\njulia> typeof(x)\nArray{Float64,2}\n\njulia> size(x)\n(5, 100)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Shapes also provides MultiShape{S,T,N,L}, which behaves as a NamedTuple of shapes and can be used to represent a collection of variables or parameters:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> multishape = MultiShape(x = ScalarShape(Real), y = VectorShape(Float64, 3))\nMultiShape{Tuple{4},Real,1,4,(x = Shape{Tuple{},Real,0,1}(), y = Shape{Tuple{3},Float64,1,3}())}()\n\njulia> multishape.y\nShape{Tuple{3},Float64,1,3}()","category":"page"},{"location":"#ShapedView-1","page":"Home","title":"ShapedView","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Perhaps the most useful feature of Shapes.jl is ShapedView, which provides a structured view of flat numerical data. A ShapedView{T,N,Shape} <: AbstractArray{T,N} behaves just like a AbstractArray{T,N} of size equal to size(Shape), but wraps a flat Vector{T} under the hood.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Random\n\nxshape = ScalarShape(Real);\nyshape = MatrixShape(Real, 5, 10);\nmultishape = MultiShape(x=xshape, y=yshape);\n\nxdata = rand(xshape);\nydata = rand(yshape);\nflatdata = [xdata, ydata...];\n\nshapedview = ShapedView(flatdata, multishape);\n# alternatively: shapedview = multishape(flatdata)\n\n@assert shapedview.x == xdata == flatdata[1]\nshapedview.x = 10\n@assert shapedview.x == 10\n\n@assert shapedview.y == ydata\n@assert shapedview.y == reshape(view(flatdata, 2:length(flatdata)), size(yshape))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Shapes can also be nested arbitraily:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"\nmultishape = MultiShape(\n    a=VectorShape(Int, 5),\n    b=MatrixShape(Int, 10, 10),\n    c = MultiShape(\n        d = ScalarShape(Int),\n        e = VectorShape(Int, 15)\n    ),\n)\n\nflatdata = Float64.(collect(1:length(multishape)))\nshapedview = ShapedView(flatdata, multishape);\n\n@assert shapedview.a == 1:5\n@assert vec(shapedview.b) == 6:105\n@assert vec(shapedview.c) == 106:121\n@assert shapedview.c.d == 106\n@assert vec(shapedview.c.e) == 107:121","category":"page"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = nothing","category":"page"}]
}
